#!/usr/bin/env python3
"""
generate.py — Build ALL LaTeX files from YAML content.

Reads:
    content/contact.yaml
    content/acronyms.yaml
    content/summary.yaml
    content/work_experience.yaml
    content/research_experience.yaml
    content/education.yaml
    content/skills.yaml
    content/certifications.yaml
    content/publications.yaml

Writes (designed CV — consumed by canvas.tex):
    generated/contact.tex
    generated/acronym.tex
    generated/summary.tex
    generated/work_experience.tex
    generated/research_experience.tex
    generated/education.tex
    generated/skills.tex
    generated/certifications.tex
    generated/publications.tex
    generated/settings.tex
    generated/.build-meta

Writes (ATS CV — self-contained):
    main_ats.tex

Requires: PyYAML (installed via apt in Docker).
"""

from __future__ import annotations

import re
import sys
from pathlib import Path

try:
    import yaml
except ImportError:
    print(
        "ERROR: PyYAML is required.  Install it with:\n"
        "  pip install pyyaml",
        file=sys.stderr,
    )
    sys.exit(1)

# ---------------------------------------------------------------------------
# Paths
# ---------------------------------------------------------------------------
ROOT = Path(__file__).resolve().parent.parent
DATA_DIR = ROOT / "content"
GENERATED_DIR = ROOT / "generated"
OUTPUT_ATS = ROOT / "main_ats.tex"

GENERATED_HEADER = (
    "% !! AUTO-GENERATED by scripts/generate.py — DO NOT EDIT !!\n"
    "% Source: content/{source}.yaml\n"
)

# ---------------------------------------------------------------------------
# YAML loading helpers
# ---------------------------------------------------------------------------

def load_yaml(name: str) -> dict:
    """Load content/<name>.yaml and return parsed dict."""
    path = DATA_DIR / f"{name}.yaml"
    if not path.exists():
        print(f"WARNING: {path} not found — skipping", file=sys.stderr)
        return {}
    with open(path, encoding="utf-8") as f:
        data = yaml.safe_load(f)
    return data if data else {}


def has_entries(data: dict) -> bool:
    """Return True if data has a non-empty 'entries' list."""
    entries = data.get("entries", [])
    return bool(entries)


# ---------------------------------------------------------------------------
# LaTeX escaping
# ---------------------------------------------------------------------------

# Characters that are special in LaTeX and must be escaped in text mode.
_LATEX_SPECIALS = [
    ("&", r"\&"),
    ("$", r"\$"),
    ("%", r"\%"),
    ("#", r"\#"),
    ("_", r"\_"),
]

# Unicode → LaTeX command replacements (applied AFTER special-char escaping
# so the braces we introduce are not themselves escaped).
_UNICODE_REPLACEMENTS = [
    ("\u00d7", r"\texttimes{}"),   # ×  multiplication sign
    ("~", r"\textasciitilde{}"),   # ~  tilde
]


def escape_latex(text: str) -> str:
    """Escape special LaTeX characters in plain text from YAML.

    Rules:
      - & $ % # _  are escaped with a backslash.
      - ×  becomes \\texttimes{}.
      - ~  becomes \\textasciitilde{}.
      - --- and -- pass through unchanged (LaTeX em-/en-dash).
    """
    if not text:
        return ""
    for old, new in _LATEX_SPECIALS:
        text = text.replace(old, new)
    for old, new in _UNICODE_REPLACEMENTS:
        text = text.replace(old, new)
    return text


# ---------------------------------------------------------------------------
# Acronym expansion (ATS only)
# ---------------------------------------------------------------------------

def expand_acronyms(text: str, acronyms: dict[str, str], seen: set[str]) -> str:
    """Expand first use of each acronym in *text*, mutating *seen*.

    Longer acronyms are matched first to avoid partial collisions.
    Overlapping matches are discarded.
    """
    expansions: list[tuple[int, int, str]] = []
    for short in sorted(acronyms, key=len, reverse=True):
        if short in seen:
            continue
        full = acronyms[short]
        escaped = re.escape(short)
        pattern = r"(?<![A-Za-z/])" + escaped + r"(?![A-Za-z/])"
        match = re.search(pattern, text)
        if match:
            overlaps = any(
                not (match.end() <= s or match.start() >= e)
                for s, e, _ in expansions
            )
            if not overlaps:
                replacement = f"{full} ({short})"
                expansions.append((match.start(), match.end(), replacement))
                seen.add(short)

    expansions.sort(key=lambda x: x[0], reverse=True)
    for start, end, replacement in expansions:
        text = text[:start] + replacement + text[end:]
    return text


# ═══════════════════════════════════════════════════════════════════
#  Settings and build metadata
# ═══════════════════════════════════════════════════════════════════

def gen_settings(contact: dict) -> str:
    """Generate generated/settings.tex with paper format and margin."""
    paper_size = contact.get("paper_size", "a4").lower()
    if paper_size not in ("a4", "letter"):
        print(f"WARNING: unknown paper_size '{paper_size}', defaulting to a4",
              file=sys.stderr)
        paper_size = "a4"

    # Margin: default depends on paper size (sweet-spot values)
    default_margin = 13.5 if paper_size == "a4" else 12.6
    margin = contact.get("margin", default_margin)

    # Validate margin is a number
    try:
        margin = float(margin)
    except (TypeError, ValueError):
        print(f"WARNING: invalid margin '{margin}', defaulting to {default_margin}",
              file=sys.stderr)
        margin = default_margin

    lines = [GENERATED_HEADER.format(source="contact")]
    lines.append(f"\\def\\PageFormat{{{paper_size}}}")
    lines.append(f"\\def\\PageMarginMM{{{margin}}}")
    return "\n".join(lines) + "\n"


def write_build_meta(contact: dict) -> None:
    """Write generated/.build-meta with dynamic output names.

    If paper_size is 'a4'     -> OUTPUT_TYPE=cv      (UK/EU convention)
    If paper_size is 'letter' -> OUTPUT_TYPE=resume   (US convention)
    Name is lowercased with spaces replaced by hyphens.
    """
    name = contact.get("name", "cv")
    paper_size = contact.get("paper_size", "a4").lower()

    # Sanitise name for filename: lowercase, spaces to hyphens, strip specials
    slug = re.sub(r"[^a-z0-9\-]", "", name.lower().replace(" ", "-"))
    slug = re.sub(r"-+", "-", slug).strip("-")
    if not slug:
        slug = "cv"

    output_type = "resume" if paper_size == "letter" else "cv"

    meta_path = GENERATED_DIR / ".build-meta"
    meta_path.write_text(
        f"OUTPUT_NAME={slug}\nOUTPUT_TYPE={output_type}\n",
        encoding="utf-8",
    )
    print(f"  Generated {meta_path.relative_to(ROOT)}")


# ═══════════════════════════════════════════════════════════════════
#  DESIGNED CV — component generators
# ═══════════════════════════════════════════════════════════════════

def gen_designed_contact(data: dict) -> str:
    """Generate generated/contact.tex."""
    lines = [GENERATED_HEADER.format(source="contact")]
    field_map = [
        ("name",        "ContactName"),
        ("title",       "ContactTitle"),
        ("email",       "ContactEmail"),
        ("phone",       "ContactPhone"),
        ("linkedin",    "ContactLinkedIn"),
        ("github",      "ContactGitHub"),
        ("location",    "ContactLocation"),
        ("full_cv_url", "ContactFullCV"),
    ]
    for yaml_key, tex_cmd in field_map:
        val = data.get(yaml_key, "")
        if val:
            lines.append(f"\\{tex_cmd}{{{val}}}")
    return "\n".join(lines) + "\n"


def gen_designed_acronyms(data: dict) -> str:
    """Generate generated/acronym.tex."""
    lines = [GENERATED_HEADER.format(source="acronyms")]
    acronyms = data.get("acronyms", {})
    for short, full in acronyms.items():
        lines.append(f"\\Acronym{{{short}}}{{{full}}}")
    return "\n".join(lines) + "\n"


def gen_designed_summary(data: dict) -> str:
    """Generate generated/summary.tex."""
    text = data.get("text", "")
    if not text:
        return ""
    lines = [GENERATED_HEADER.format(source="summary")]
    lines.append(escape_latex(text))
    return "\n".join(lines)


def gen_designed_work(data: dict) -> str:
    """Generate generated/work_experience.tex."""
    entries = data.get("entries", [])
    if not entries:
        return ""
    lines = [GENERATED_HEADER.format(source="work_experience")]

    for i, entry in enumerate(entries):
        role = escape_latex(entry.get("role", ""))
        company = escape_latex(entry.get("company", ""))
        dates = entry.get("dates", "")
        location = entry.get("location", "")

        # Convert month-name dates to MM/YYYY format for designed CV
        dates_designed = _dates_to_designed(dates)

        lines.append(f"\\JobHead{{{role}}}")
        lines.append(f"    {{{company}}}")
        lines.append(f"    {{{dates_designed}}}")
        lines.append(f"    {{{location}}}")
        lines.append("\\begin{treelist}")

        bullets = entry.get("bullets", [])
        for j, bullet in enumerate(bullets):
            cmd = "\\TreeLast" if j == len(bullets) - 1 else "\\TreeItem"
            lines.append(f"    {cmd}{{{escape_latex(bullet)}}}")
        lines.append("\\end{treelist}")

        if i < len(entries) - 1:
            lines.append("")
            lines.append("\\JobSep")
            lines.append("")

    return "\n".join(lines) + "\n"


def gen_designed_research(data: dict) -> str:
    """Generate generated/research_experience.tex."""
    entries = data.get("entries", [])
    if not entries:
        return ""
    lines = [GENERATED_HEADER.format(source="research_experience")]

    for i, entry in enumerate(entries):
        # Project title for designed CV (falls back to role)
        project_title = escape_latex(
            entry.get("project_title", entry.get("role", ""))
        )

        # Subtitle: explicit override or auto-built
        subtitle = entry.get("designed_subtitle", "")
        if not subtitle:
            company = entry.get("company", "")
            role = entry.get("role", "")
            dates = entry.get("dates", "")
            subtitle = f"{company}, {role} | {dates}"
        subtitle = escape_latex(subtitle)

        # First entry uses \SubHeadFirst (no top gap)
        head_cmd = "\\SubHeadFirst" if i == 0 else "\\SubHeadFirst"
        lines.append(f"{head_cmd}{{{project_title}}}")
        lines.append(f"{{{subtitle}}}")

        # Optional description
        desc = entry.get("description", "")
        if desc:
            lines.append("")
            lines.append(f"\\Desc{{{escape_latex(desc)}}}")

        # Subsections
        subsections = entry.get("subsections", [])
        for sub in subsections:
            heading = escape_latex(sub.get("heading", ""))
            lines.append("")
            lines.append(f"\\SubHead{{{heading}}}")
            lines.append("\\begin{treelist}")
            bullets = sub.get("bullets", [])
            for j, bullet in enumerate(bullets):
                cmd = "\\TreeLast" if j == len(bullets) - 1 else "\\TreeItem"
                lines.append(f"    {cmd}{{{escape_latex(bullet)}}}")
            lines.append("\\end{treelist}")

    return "\n".join(lines) + "\n"


def gen_designed_education(data: dict) -> str:
    """Generate generated/education.tex."""
    entries = data.get("entries", [])
    if not entries:
        return ""
    lines = [GENERATED_HEADER.format(source="education")]
    lines.append("\\begin{timeline}")

    for i, entry in enumerate(entries):
        degree = escape_latex(entry.get("degree", ""))
        institution = escape_latex(entry.get("institution", ""))
        dates = entry.get("dates", "")
        location = entry.get("location", "")
        details = entry.get("details", "")
        progress = entry.get("progress")

        # Choose timeline command variant
        if i == 0:
            cmd = "\\TimelineItemFirst"
        elif i == len(entries) - 1:
            cmd = "\\TimelineLast"
        else:
            cmd = "\\TimelineItem"

        # Build body content
        body_parts = [institution + "\\\\"]

        # Date line (with optional location)
        if location:
            body_parts.append(f"    {dates} \\quad {location}\\\\")
        else:
            body_parts.append(f"    {dates}\\\\")

        # Details / progress bar
        if progress is not None and details:
            label = escape_latex(details)
            body_parts.append(f"    \\ProgressBar{{{progress}}}{{{label}}}%")
        elif details:
            body_parts.append(f"    {escape_latex(details)}%")
        else:
            # Remove trailing \\ from last line
            body_parts[-1] = body_parts[-1].rstrip("\\\\") + "%"

        body = "\n        ".join(body_parts)
        lines.append(f"    {cmd}{{{degree}}}{{%")
        lines.append(f"        {body}")
        lines.append("    }")

        # Spacing between items (not after last)
        if i < len(entries) - 1:
            lines.append("    \\vspace{\\GapTimelineItem\\TPVertModule}%")
            lines.append("")

    lines.append("\\end{timeline}")
    return "\n".join(lines) + "\n"


def gen_designed_skills(data: dict) -> str:
    """Generate generated/skills.tex."""
    groups = data.get("groups", [])
    if not groups:
        return ""
    lines = [GENERATED_HEADER.format(source="skills")]

    for i, group in enumerate(groups):
        category = escape_latex(group.get("category", ""))
        items = group.get("items", [])

        cmd = "\\SkillCatFirst" if i == 0 else "\\SkillCat"
        lines.append(f"{cmd}{{{category}}}")
        lines.append("\\begin{skilllist}")
        for item in items:
            lines.append(f"    \\item {escape_latex(item)}")
        lines.append("\\end{skilllist}")

        if i < len(groups) - 1:
            lines.append("\\vspace{\\GapSkillCat\\TPVertModule}%")

    return "\n".join(lines) + "\n"


def gen_designed_certifications(data: dict) -> str:
    """Generate generated/certifications.tex (empty if no entries)."""
    entries = data.get("entries", [])
    if not entries:
        return ""
    lines = [GENERATED_HEADER.format(source="certifications")]
    for entry in entries:
        name = escape_latex(entry.get("name", ""))
        issuer = escape_latex(entry.get("issuer", ""))
        year = entry.get("year", "")
        lines.append(f"\\textbf{{{name}}} --- {issuer} \\hfill {year}")
        lines.append("")
    return "\n".join(lines) + "\n"


def gen_designed_publications(data: dict) -> str:
    """Generate generated/publications.tex (empty if no entries)."""
    entries = data.get("entries", [])
    if not entries:
        return ""
    lines = [GENERATED_HEADER.format(source="publications")]
    for entry in entries:
        authors = escape_latex(entry.get("authors", ""))
        title = escape_latex(entry.get("title", ""))
        venue = escape_latex(entry.get("venue", ""))
        year = entry.get("year", "")
        lines.append(f"{authors}. \\textit{{{title}}}. {venue}, {year}.")
        lines.append("")
    return "\n".join(lines) + "\n"


# ═══════════════════════════════════════════════════════════════════
#  ATS CV — full document generator
# ═══════════════════════════════════════════════════════════════════

ATS_PREAMBLE = r"""\documentclass[a4paper,11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[margin=25.4mm]{geometry}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}

% No paragraph indent, small gap between paragraphs
\setlength{\parindent}{0pt}

% Raggedright globally — prevents variable word spacing
\raggedright

% Section heading format — zero decoration
\titleformat{\section}{\large\bfseries}{}{0em}{}
\titlespacing{\section}{0pt}{12pt}{6pt}

% No page numbers (they go in footers, which parsers often skip)
\pagestyle{empty}

\begin{document}
"""

ATS_POSTAMBLE = r"""
\end{document}
"""


def ats_contact_block(contact: dict) -> str:
    """Build centred ATS contact block."""
    name = contact.get("name", "Your Name")
    email = contact.get("email", "")
    phone = contact.get("phone", "")
    location = contact.get("location", "")
    linkedin = contact.get("linkedin", "")
    github = contact.get("github", "")
    full_cv = contact.get("full_cv_url", "")

    lines = [
        "% === CONTACT BLOCK ===",
        "\\begin{center}",
        f"{{\\LARGE\\bfseries {escape_latex(name)}}}\\\\[4pt]",
        f"{escape_latex(email)} \\quad {phone} \\quad {escape_latex(location)}\\\\[2pt]",
    ]
    urls: list[str] = []
    if linkedin:
        urls.append(f"\\url{{https://{linkedin}}}")
    if github:
        urls.append(f"\\url{{https://{github}}}")
    if urls:
        lines.append(" \\quad ".join(urls))
    lines.append("\\end{center}")
    lines.append("")

    if full_cv:
        lines.append("\\smallskip")
        lines.append(f"\\noindent\\textbf{{Full CV:}} \\url{{{full_cv}}}\\\\")
        lines.append(
            "{\\small\\textit{This document is formatted for applicant tracking "
            "systems. A designed version with full detail is available at the "
            "link above.}}"
        )
        lines.append("")
    lines.append("\\bigskip")
    return "\n".join(lines)


def ats_summary(data: dict, acronyms: dict[str, str]) -> str:
    """Render ATS PROFESSIONAL SUMMARY section."""
    text = data.get("text", "")
    if not text:
        return ""
    text = escape_latex(text)
    seen: set[str] = set()
    text = expand_acronyms(text, acronyms, seen)
    return f"\\section{{PROFESSIONAL SUMMARY}}\n{text}\n"


def ats_experience(
    data: dict,
    section_name: str,
    acronyms: dict[str, str],
    flatten_subsections: bool = False,
) -> str:
    """Render ATS experience section (work or research)."""
    entries = data.get("entries", [])
    if not entries:
        return ""

    seen: set[str] = set()
    lines = [f"\\section{{{section_name}}}\n"]

    for i, entry in enumerate(entries):
        role = expand_acronyms(escape_latex(entry.get("role", "")), acronyms, seen)
        company = expand_acronyms(escape_latex(entry.get("company", "")), acronyms, seen)
        dates = entry.get("dates", "")
        location = entry.get("location", "")

        lines.append(f"\\textbf{{{role}}} \\hfill {dates}\\\\")
        lines.append(f"{company} \\hfill {location}")

        # Optional description
        desc = entry.get("description", "")
        if desc:
            desc = expand_acronyms(escape_latex(desc), acronyms, seen)
            lines.append(f"\n{desc}\n")

        # Collect bullets (flatten subsections for ATS readability)
        all_bullets: list[str] = []

        # Direct bullets (work experience style)
        for b in entry.get("bullets", []):
            all_bullets.append(expand_acronyms(escape_latex(b), acronyms, seen))

        # Subsection bullets (research experience style)
        for sub in entry.get("subsections", []):
            heading = sub.get("heading", "")
            sub_bullets = sub.get("bullets", [])
            if heading and flatten_subsections and sub_bullets:
                first = (
                    f"\\textbf{{{expand_acronyms(escape_latex(heading), acronyms, seen)}:}} "
                    f"{expand_acronyms(escape_latex(sub_bullets[0]), acronyms, seen)}"
                )
                all_bullets.append(first)
                for b in sub_bullets[1:]:
                    all_bullets.append(expand_acronyms(escape_latex(b), acronyms, seen))
            else:
                for b in sub_bullets:
                    all_bullets.append(expand_acronyms(escape_latex(b), acronyms, seen))

        if all_bullets:
            lines.append("\\begin{itemize}[leftmargin=1.5em, itemsep=2pt, parsep=0pt]")
            for b in all_bullets:
                lines.append(f"  \\item {b}")
            lines.append("\\end{itemize}")

        if i < len(entries) - 1:
            lines.append("")

    return "\n".join(lines) + "\n"


def ats_skills(data: dict, acronyms: dict[str, str]) -> str:
    """Render ATS SKILLS section."""
    groups = data.get("groups", [])
    if not groups:
        return ""

    seen: set[str] = set()
    lines = ["\\section{SKILLS}\n"]
    rendered: list[str] = []
    for group in groups:
        cat = expand_acronyms(escape_latex(group.get("category", "")), acronyms, seen)
        # Join all items into comma-separated string
        items_flat = ", ".join(group.get("items", []))
        itm = expand_acronyms(escape_latex(items_flat), acronyms, seen)
        rendered.append(f"\\textbf{{{cat}:}} {itm}")
    lines.append("\\\\\\relax\n".join(rendered))
    return "\n".join(lines) + "\n"


def ats_education(data: dict, acronyms: dict[str, str]) -> str:
    """Render ATS EDUCATION section."""
    entries = data.get("entries", [])
    if not entries:
        return ""

    seen: set[str] = set()
    lines = ["\\section{EDUCATION}\n"]

    for i, entry in enumerate(entries):
        degree = expand_acronyms(escape_latex(entry.get("degree", "")), acronyms, seen)
        institution = expand_acronyms(escape_latex(entry.get("institution", "")), acronyms, seen)
        dates = entry.get("dates", "")
        location = entry.get("location", "")
        details = entry.get("details", "")

        line1 = f"\\textbf{{{degree}}} \\hfill {dates}"
        if location:
            line2 = f"{institution} \\hfill {location}"
        else:
            line2 = institution
        lines.append(f"{line1}\\\\")
        lines.append(line2)
        if details:
            lines.append(f"\\\\\n\\textit{{{escape_latex(details)}}}")

        if i < len(entries) - 1:
            lines.append("\n\\medskip\n")

    return "\n".join(lines) + "\n"


def ats_publications(data: dict, acronyms: dict[str, str]) -> str:
    """Render ATS PUBLICATIONS section."""
    entries = data.get("entries", [])
    if not entries:
        return ""

    seen: set[str] = set()
    lines = ["\\section{PUBLICATIONS}\n"]
    for entry in entries:
        authors = escape_latex(entry.get("authors", ""))
        title = escape_latex(entry.get("title", ""))
        venue = escape_latex(entry.get("venue", ""))
        year = entry.get("year", "")
        text = f"{authors}. \\textit{{{title}}}. {venue}, {year}."
        text = expand_acronyms(text, acronyms, seen)
        lines.append(text)
        lines.append("")
    return "\n".join(lines) + "\n"


def ats_certifications(data: dict, acronyms: dict[str, str]) -> str:
    """Render ATS CERTIFICATIONS section."""
    entries = data.get("entries", [])
    if not entries:
        return ""

    seen: set[str] = set()
    lines = ["\\section{CERTIFICATIONS}\n"]
    for entry in entries:
        name = escape_latex(entry.get("name", ""))
        issuer = escape_latex(entry.get("issuer", ""))
        year = entry.get("year", "")
        text = f"\\textbf{{{name}}} --- {issuer} \\hfill {year}"
        text = expand_acronyms(text, acronyms, seen)
        lines.append(text)
        lines.append("")
    return "\n".join(lines) + "\n"


# ---------------------------------------------------------------------------
# Date formatting helper
# ---------------------------------------------------------------------------

_MONTH_MAP = {
    "jan": "01", "feb": "02", "mar": "03", "apr": "04",
    "may": "05", "jun": "06", "jul": "07", "aug": "08",
    "sep": "09", "oct": "10", "nov": "11", "dec": "12",
}


def _dates_to_designed(dates: str) -> str:
    """Convert 'Mon YYYY -- Mon YYYY' to 'MM/YYYY -- MM/YYYY' for the designed CV.

    Examples:
        'Mar 2023 -- Feb 2024'  → '03/2023 -- 02/2024'
        'Oct 2008 -- Jan 2014'  → '10/2008 -- 01/2014'
        'Feb 2019 -- Present'   → '02/2019 -- Present'
        '2024 -- 2026'          → '2024 -- 2026'  (no month, pass through)
    """
    def _convert_part(part: str) -> str:
        part = part.strip()
        if part.lower() == "present":
            return "Present"
        match = re.match(r"([A-Za-z]{3})\s+(\d{4})", part)
        if match:
            month_str, year = match.groups()
            month_num = _MONTH_MAP.get(month_str.lower())
            if month_num:
                return f"{month_num}/{year}"
        return part  # pass through if no match

    if " -- " in dates:
        parts = dates.split(" -- ", 1)
        return " -- ".join(_convert_part(p) for p in parts)
    return _convert_part(dates)


# ---------------------------------------------------------------------------
# File writers
# ---------------------------------------------------------------------------

def write_component(name: str, content: str) -> None:
    """Write a generated .tex file (or skip if content is empty)."""
    path = GENERATED_DIR / f"{name}.tex"
    if not content:
        # Write an empty file so \input doesn't fail
        path.write_text("", encoding="utf-8")
        return
    path.write_text(content, encoding="utf-8")
    print(f"  Generated {path.relative_to(ROOT)}")


# ═══════════════════════════════════════════════════════════════════
#  Main
# ═══════════════════════════════════════════════════════════════════

def main() -> None:
    """Entry point: load YAML data, generate all LaTeX files."""

    # ------------------------------------------------------------------
    # Load all data
    # ------------------------------------------------------------------
    contact = load_yaml("contact")
    acronyms_data = load_yaml("acronyms")
    summary = load_yaml("summary")
    work = load_yaml("work_experience")
    research = load_yaml("research_experience")
    education = load_yaml("education")
    skills = load_yaml("skills")
    certifications = load_yaml("certifications")
    publications = load_yaml("publications")

    if not contact:
        print("ERROR: content/contact.yaml not found or empty", file=sys.stderr)
        sys.exit(1)

    acronyms = acronyms_data.get("acronyms", {})

    # ------------------------------------------------------------------
    # Generate settings and build metadata
    # ------------------------------------------------------------------
    print("Generating settings and build metadata...")
    write_component("settings", gen_settings(contact))
    write_build_meta(contact)

    # ------------------------------------------------------------------
    # Generate designed CV components
    # ------------------------------------------------------------------
    print("Generating designed CV components...")
    write_component("contact", gen_designed_contact(contact))
    write_component("acronym", gen_designed_acronyms(acronyms_data))
    write_component("summary", gen_designed_summary(summary))
    write_component("work_experience", gen_designed_work(work))
    write_component("research_experience", gen_designed_research(research))
    write_component("education", gen_designed_education(education))
    write_component("skills", gen_designed_skills(skills))
    write_component("certifications", gen_designed_certifications(certifications))
    write_component("publications", gen_designed_publications(publications))

    # ------------------------------------------------------------------
    # Generate ATS CV (single self-contained file)
    # ------------------------------------------------------------------
    print("Generating ATS CV...")

    sections: list[str] = []
    sections.append(ats_summary(summary, acronyms))
    sections.append(ats_experience(
        research, "RESEARCH EXPERIENCE", acronyms, flatten_subsections=True))
    sections.append(ats_experience(
        work, "WORK EXPERIENCE", acronyms, flatten_subsections=False))
    sections.append(ats_skills(skills, acronyms))
    sections.append(ats_education(education, acronyms))
    sections.append(ats_publications(publications, acronyms))
    sections.append(ats_certifications(certifications, acronyms))

    sections = [s for s in sections if s.strip()]

    doc = ATS_PREAMBLE
    doc += ats_contact_block(contact)
    doc += "\n"
    doc += "\n".join(sections)
    doc += ATS_POSTAMBLE

    OUTPUT_ATS.write_text(doc, encoding="utf-8")
    print(f"  Generated {OUTPUT_ATS.relative_to(ROOT)}")

    print("Done.")


if __name__ == "__main__":
    main()
